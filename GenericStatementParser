using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using UG_DT_DeepLenz.models;

namespace UG_DT_DeepLenz.parsers
{

    public sealed class GenericStatementParser : IBankValueDateParser
    {
        public string Bank => _activeProfile?.BankName ?? "Generic (Auto)";
        public bool Diagnostics { get; set; } = true;

        private readonly Profile? _forcedProfile;
        private Profile? _activeProfile;

        public GenericStatementParser(Profile? forced = null) { _forcedProfile = forced; }
        public GenericStatementParser() : this(null) { }

        private void Log(string msg) { if (Diagnostics) Console.WriteLine(msg); }

        public bool CanHandle(string rawText)
        {
            if (string.IsNullOrWhiteSpace(rawText)) return false;
            var p = _forcedProfile ?? DetectProfile(rawText) ?? Profiles.Default();
            return p.DateAnyRx.IsMatch(rawText ?? "");
        }

        public IEnumerable<ValueDateTxn> Parse(string rawText)
        {
            var outRows = new List<ValueDateTxn>();
            if (string.IsNullOrWhiteSpace(rawText))
            {
                Log("[Diag] Input empty.");
                return outRows;
            }

            // ---- Choose profile
            var p = _forcedProfile ?? DetectProfile(rawText) ?? Profiles.Default();
            _activeProfile = p;

            // ---- Normalize text
            var normalized = Normalize(rawText);
            var linesAll = normalized.Split('\n').Select(s => s.Trim()).Where(s => s.Length > 0).ToList();

            // ---- Soft-cut boilerplate lines (keep those that also contain dates or money)
            var lines = new List<string>(linesAll.Count);
            foreach (var l in linesAll)
            {
                if (ShouldDropLine(l, p))
                {
                    // Keep if line also has a date or money – might contain a legitimate row
                    if (!(p.DateAnyRx.IsMatch(l) || LineHasMoney(l, p)))
                        continue;
                }
                lines.Add(l);
            }

            Log($"[Diag] Profile: {p.BankName}");
            Log($"[Diag] Lines kept: {lines.Count} (from {linesAll.Count})");

            // ---- Stitch lines into blobs (each blob begins when a new date appears)
            var blobs = Stitch(lines, p);
            if (blobs.Count == 0)
            {
                // Fallback: no line matched date-at-start; treat each line with date or money as its own blob so we still extract rows/D&C
                blobs = StitchFallback(lines, p);
                Log($"[Diag] Blobs (fallback): {blobs.Count}");
            }
            else
                Log($"[Diag] Blobs: {blobs.Count}");

            if (blobs.Count == 0) return outRows;

            // ---- Split blobs into candidate rows at date boundaries
            var rowCandidates = blobs.SelectMany(b => SplitRowsByAnyDate(b, p)).ToList();
            Log($"[Diag] Row candidates: {rowCandidates.Count}");

            // ---- Parse rows (balance-first); D/C computed from balance deltas later
            int droppedNoDates = 0, droppedNoBalance = 0;
            foreach (var rc in rowCandidates)
            {
                var row = ParseRow(rc, p, out bool noDates, out bool noBalance);
                if (row == null)
                {
                    if (noDates) droppedNoDates++;
                    if (noBalance) droppedNoBalance++;
                    continue;
                }

                outRows.Add(new ValueDateTxn
                {
                    TransactionDate = row.TranDate,
                    ValueDate = row.ValueDate,
                    Description = row.Description,
                    Debit = null,   // computed from balance deltas below
                    Credit = null,
                    Balance = row.Balance
                });
            }

            Log($"[Diag] Parsed rows (pre-D/C): {outRows.Count}, droppedNoDates:{droppedNoDates}, droppedNoBalance:{droppedNoBalance}");

            // ---- Enforce: rows must have at least one date
            outRows = outRows.Where(r => r.TransactionDate.HasValue || r.ValueDate.HasValue).ToList();

            // ---- Compute Debits/Credits: from balance deltas OR from single amount + description keywords
            if (p.SingleAmountPerRow)
                outRows = ClassifyDebitCreditFromDescription(outRows, p);
            else
                outRows = ComputeDebitsCreditsFromBalance(outRows);

            // ---- Optional: remove duplicate rows (same date, value date, description, amount)
            outRows = DedupeByKey(outRows);

            if (outRows.Count > 0)
            {
                var f = outRows[0]; var l = outRows[^1];
                Log($"[Diag] First: {f.TransactionDate?.ToString("dd/MM/yyyy")} {f.ValueDate?.ToString("dd/MM/yyyy")} | {f.Description} | D:{f.Debit} C:{f.Credit} Bal:{f.Balance}");
                Log($"[Diag] Last : {l.TransactionDate?.ToString("dd/MM/yyyy")} {l.ValueDate?.ToString("dd/MM/yyyy")} | {l.Description} | D:{l.Debit} C:{l.Credit} Bal:{l.Balance}");
            }

            return outRows;
        }

        // ----------------- Row model -----------------

        private sealed class ParsedRow
        {
            public DateTime? TranDate { get; init; }
            public DateTime? ValueDate { get; init; }
            public string Description { get; init; } = "";
            public decimal Balance { get; init; }
        }

        // ----------------- Parsing logic -----------------

        private static ParsedRow? ParseRow(string s, Profile p, out bool droppedNoDates, out bool droppedNoBalance)
        {
            droppedNoDates = droppedNoBalance = false;
            if (string.IsNullOrWhiteSpace(s)) { droppedNoDates = true; return null; }

            // Trim trailing junk but preserve last date so we don't drop date when balance appears first
            s = TruncateAfterFinalMoney(s, p);

            // Tokenize
            var tokens = Split(s);
            if (tokens.Count == 0) { droppedNoDates = true; return null; }

            // Find first and optional second date ANYWHERE in the tokens
            if (!TryFindDatesAnywhere(tokens, p, out var tDate, out var vDate, out var firstNonDateIdx))
            {
                droppedNoDates = true;
                return null;
            }

            // Find rightmost money (Balance). Accept CR/DR suffixes and split CR/DR tokens.
            if (!TryFindRightmostBalance(tokens, p, out var balIndex, out var balance))
            {
                // Still emit a row when we have dates so we get transactions; D/C will be from deltas where balance exists
                droppedNoBalance = true;
                balance = 0m;
                balIndex = tokens.Count;
            }

            // Description: tokens between (last date token) and the balance token
            var descTokens = tokens.Skip(firstNonDateIdx).Take(Math.Max(0, balIndex - firstNonDateIdx)).ToList();

            // Many layouts have the transaction amount just before balance; drop one trailing money token if present
            if (descTokens.Count > 0 && LooksLikeMoney(descTokens[^1], p))
                descTokens.RemoveAt(descTokens.Count - 1);

            var desc = string.Join(" ", descTokens).Trim();

            // Ensure at least one date present
            var txn = tDate ?? vDate;
            var val = vDate ?? tDate;
            if (!txn.HasValue && !val.HasValue) { droppedNoDates = true; return null; }

            return new ParsedRow
            {
                TranDate = txn,
                ValueDate = val,
                Description = desc,
                Balance = balance
            };
        }

        // ----------------- Post-pass: D/C from single amount + description keywords (no balance column) -----------------

        private List<ValueDateTxn> ClassifyDebitCreditFromDescription(List<ValueDateTxn> rows, Profile p)
        {
            foreach (var r in rows)
            {
                if (ContainsIgnoreMarker(r.Description))
                {
                    r.Debit = null; r.Credit = null;
                    continue;
                }
                decimal amount = r.Balance;
                if (amount == 0) { r.Debit = null; r.Credit = null; continue; }
                var up = (r.Description ?? "").ToUpperInvariant();
                bool isDebit = p.DebitKeywords.Length > 0 && p.DebitKeywords.Any(k => up.Contains(k));
                bool isCredit = p.CreditKeywords.Length > 0 && p.CreditKeywords.Any(k => up.Contains(k));
                if (isDebit && !isCredit) { r.Debit = amount; r.Credit = null; }
                else if (isCredit && !isDebit) { r.Credit = amount; r.Debit = null; }
                else if (isDebit && isCredit) { r.Debit = amount; r.Credit = null; } // ambiguous → treat as debit
                else { r.Debit = amount; r.Credit = null; } // default: treat as debit (outflow) when unknown
            }
            return rows;
        }

        private static List<ValueDateTxn> DedupeByKey(List<ValueDateTxn> rows)
        {
            var seen = new HashSet<string>();
            var outList = new List<ValueDateTxn>(rows.Count);
            foreach (var r in rows)
            {
                var key = $"{r.TransactionDate?.ToString("yyyy-MM-dd")}|{r.ValueDate?.ToString("yyyy-MM-dd")}|{r.Description?.Trim()}|{r.Balance}|{r.Debit}|{r.Credit}";
                if (seen.Add(key)) outList.Add(r);
            }
            return outList;
        }

        // ----------------- Post-pass: D/C from balance deltas -----------------

        private List<ValueDateTxn> ComputeDebitsCreditsFromBalance(List<ValueDateTxn> rows)
        {
            if (rows.Count == 0) return rows;

            decimal? baseline = null;

            for (int i = 0; i < rows.Count; i++)
            {
                var r = rows[i];
                bool hasDate = r.TransactionDate.HasValue || r.ValueDate.HasValue;

                // Skip D/C if no date (but advance baseline)
                if (!hasDate)
                {
                    if (Diagnostics)
                        Log($"[Diag/Diff] Row {i}: NO DATE → D/C=null; baseline={r.Balance:N2}");
                    r.Debit = null; r.Credit = null; baseline = r.Balance; continue;
                }

                // Skip D/C for ignored descriptions (but advance baseline)
                if (ContainsIgnoreMarker(r.Description))
                {
                    if (Diagnostics)
                        Log($"[Diag/Diff] Row {i}: IGNORE ('{r.Description}') → D/C=null; baseline={r.Balance:N2}");
                    r.Debit = null; r.Credit = null; baseline = r.Balance; continue;
                }

                if (!baseline.HasValue)
                {
                    if (Diagnostics)
                        Log($"[Diag/Diff] Row {i}: FIRST usable → D/C=null; baseline={r.Balance:N2}");
                    r.Debit = null; r.Credit = null; baseline = r.Balance; continue;
                }

                var delta = r.Balance - baseline.Value;
                var abs = Math.Abs((decimal)delta);

                r.Debit = delta < 0 ? abs : (decimal?)null;
                r.Credit = delta > 0 ? abs : (decimal?)null;

                if (Diagnostics)
                {
                    var kind = delta < 0 ? $"DEBIT {abs:N2}" : delta > 0 ? $"CREDIT {abs:N2}" : "NO-CHANGE";
                    Log($"[Diag/Diff] Row {i}: prev={baseline.Value:N2} -> curr={r.Balance:N2} Δ={delta:N2} → {kind} | '{r.Description}'");
                }

                baseline = r.Balance;
            }

            return rows;
        }

        // ----------------- Stitch / Split -----------------

        private static List<string> Stitch(List<string> lines, Profile p)
        {
            var output = new List<string>();
            var buf = new StringBuilder();

            bool StartsRow(string ln) => p.DateAnyRx.IsMatch(ln);

            foreach (var l in lines.Select(x => TruncateAfterFinalMoney(x, p)))
            {
                if (StartsRow(l))
                {
                    if (buf.Length > 0)
                    {
                        output.Add(buf.ToString().Trim());
                        buf.Clear();
                    }
                    buf.Append(l);
                }
                else if (buf.Length > 0)
                {
                    buf.Append(' ').Append(l);
                }
            }

            if (buf.Length > 0) output.Add(buf.ToString().Trim());
            return output;
        }

        /// <summary>When Stitch gives 0 blobs (no line starts with a date), form one blob per line that contains a date or money so we can still extract rows and D/C.</summary>
        private static List<string> StitchFallback(List<string> lines, Profile p)
        {
            var output = new List<string>();
            foreach (var l in lines)
            {
                if (string.IsNullOrWhiteSpace(l)) continue;
                if (p.DateAnyRx.IsMatch(l) || LineHasMoney(l, p))
                    output.Add(l.Trim());
            }
            return output;
        }

        private static IEnumerable<string> SplitRowsByAnyDate(string blob, Profile p)
        {
            if (string.IsNullOrWhiteSpace(blob)) yield break;

            var parts = p.RowSplitAnyDateRx.Split(blob);
            foreach (var part in parts)
            {
                var s = (part ?? "").Trim();
                if (s.Length > 0) yield return s;
            }
        }

        // ----------------- Normalization & Filters -----------------

        private static string Normalize(string t)
        {
            if (string.IsNullOrWhiteSpace(t)) return t;

            t = t.Replace("\r", "\n").Replace("\u00A0", " "); // NBSP → space

            // Unicode dashes → ASCII '-'
            t = t.Replace("\u2010", "-").Replace("\u2011", "-")
                 .Replace("\u2012", "-").Replace("\u2013", "-")
                 .Replace("\u2014", "-").Replace("\u2212", "-");

            // Strip Unicode format/invisible chars
            t = Regex.Replace(t, @"\p{Cf}", "");

            // Standardize whitespace a bit (keep \n for line logic)
            t = Regex.Replace(t, @"[ \t]+", " ");
            t = Regex.Replace(t, @"\n{2,}", "\n");

            return t.Trim();
        }

        private static bool ShouldDropLine(string l, Profile p)
        {
            // If line contains explicit cut markers and does NOT contain dates or money, drop it
            // (We check dates/money outside to decide keeping)
            foreach (var m in p.CutMarkers)
            {
                if (l.IndexOf(m, StringComparison.OrdinalIgnoreCase) >= 0)
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Truncate line after the last meaningful token, but never drop the last date.
        /// Keeps tokens from start through max(last date index, last money index).
        /// </summary>
        private static string TruncateAfterFinalMoney(string line, Profile p)
        {
            if (string.IsNullOrWhiteSpace(line)) return line;

            if (p.PageCounterTailRx != null)
                line = p.PageCounterTailRx.Replace(line, "");

            if (p.GluedHeadersTailRx != null)
                line = p.GluedHeadersTailRx.Replace(line, "");

            var tokens = Split(line);
            if (tokens.Count == 0) return line;

            int lastDateIdx = -1;
            int lastMoneyIdx = -1;

            // Single-token and multi-token date (e.g. "22 02 2025")
            for (int i = 0; i < tokens.Count; i++)
            {
                if (p.DateAnyRx.IsMatch(tokens[i])) { lastDateIdx = i; continue; }
                if (i + 1 < tokens.Count)
                {
                    var s2 = string.Join(" ", tokens.Skip(i).Take(2));
                    if (p.DateAnyRx.IsMatch(s2)) { lastDateIdx = i + 1; continue; }
                }
                if (i + 2 < tokens.Count)
                {
                    var s3 = string.Join(" ", tokens.Skip(i).Take(3));
                    if (p.DateAnyRx.IsMatch(s3)) { lastDateIdx = i + 2; continue; }
                }
            }
            for (int i = 0; i < tokens.Count; i++)
            {
                bool moneyHere = LooksLikeMoney(tokens[i], p)
                                 || (i + 1 < tokens.Count && IsCrDr(tokens[i + 1]) && LooksLikeMoney(tokens[i], p))
                                 || MoneyZeroRx.IsMatch(tokens[i])
                                 || PlainIntRx.IsMatch(tokens[i]);
                if (moneyHere) lastMoneyIdx = i;
            }
            for (int i = 0; i < tokens.Count - 1; i++)
            {
                if (IsCrDr(tokens[i + 1]) && LooksLikeMoney(tokens[i], p))
                    lastMoneyIdx = Math.Max(lastMoneyIdx, i + 1);
            }

            int keepThrough = Math.Max(lastDateIdx, lastMoneyIdx);
            if (keepThrough >= 0)
                return string.Join(" ", tokens.Take(keepThrough + 1));

            return line;
        }

        // Returns true if the line contains something that looks like a money token.
        private static bool LineHasMoney(string line, Profile p)
        {
            if (string.IsNullOrWhiteSpace(line)) return false;

            foreach (var tok in Split(line))
            {
                if (LooksLikeMoney(tok, p))                  // e.g., "123,456.00", "(1,234)", "2,000CR"
                    return true;

                if (MoneyZeroRx.IsMatch(tok) || PlainIntRx.IsMatch(tok) || LooseMoneyRx.IsMatch(tok))
                    return true;
            }
            return false;
        }


        private static List<string> Split(string s)
            => Regex.Split(s ?? "", @"\s+").Where(x => x.Length > 0).ToList();

        // ----------------- Date & Money helpers -----------------

        private static readonly CultureInfo CI = CultureInfo.GetCultureInfo("en-UG");

        private static readonly string[] ExtraDateFormats =
        {
            "yyyy-MM-dd", "yyyy/MM/dd", "yyyy.MM.dd",
            "dd.MM.yyyy", "d.M.yyyy", "dd.MM.yy", "d.M.yy",
            "dd MMM yyyy", "d MMM yyyy",
            "dd MMMM yyyy", "d MMMM yyyy",
            "MM/dd/yyyy", "M/d/yyyy",
            "dd MM yyyy", "d M yyyy", "dd MM yy", "d M yy",
            "yyyy MM dd"
        };

        private static bool TryParseDateFlexible(string s, Profile p, out DateTime dt)
        {
            s = (s ?? "").Trim();
            // Title-case month names like jan/JAN → Jan
            s = Regex.Replace(s, @"([A-Za-z]{3,})",
                 m => CultureInfo.InvariantCulture.TextInfo.ToTitleCase(m.Value.ToLowerInvariant()));

            // Try profile formats
            if (DateTime.TryParseExact(s, p.DateFormats, CI,
                    DateTimeStyles.AllowWhiteSpaces | DateTimeStyles.AssumeLocal, out dt))
                return true;

            // Try extras
            if (DateTime.TryParseExact(s, ExtraDateFormats, CI,
                    DateTimeStyles.AllowWhiteSpaces | DateTimeStyles.AssumeLocal, out dt))
                return true;

            // Last resort
            return DateTime.TryParse(s, CI, DateTimeStyles.AllowWhiteSpaces | DateTimeStyles.AssumeLocal, out dt);
        }

        private static bool TryFindDatesAnywhere(
            List<string> tokens, Profile p,
            out DateTime? tran, out DateTime? value, out int firstNonDateIdx)
        {
            tran = null; value = null; firstNonDateIdx = 0;
            // (startIndex, tokenLength) for each date found (so we support multi-token dates like "22 Feb 2025")
            var dateSpans = new List<(int start, int len)>();

            for (int i = 0; i < tokens.Count && dateSpans.Count < 2; )
            {
                int len = 0;
                DateTime dt;

                // Try 3 tokens (e.g. "22 02 2025" or "22 Feb 2025")
                if (i + 2 < tokens.Count)
                {
                    var s3 = string.Join(" ", tokens.Skip(i).Take(3));
                    if (p.DateAnyRx.IsMatch(s3) && TryParseDateFlexible(s3, p, out dt)) len = 3;
                }
                // Try 2 tokens
                if (len == 0 && i + 1 < tokens.Count)
                {
                    var s2 = string.Join(" ", tokens.Skip(i).Take(2));
                    if (p.DateAnyRx.IsMatch(s2) && TryParseDateFlexible(s2, p, out dt)) len = 2;
                }
                // Try 1 token
                if (len == 0 && p.DateAnyRx.IsMatch(tokens[i]) && TryParseDateFlexible(tokens[i], p, out dt)) len = 1;

                if (len > 0)
                {
                    dateSpans.Add((i, len));
                    i += len;
                }
                else
                    i++;
            }

            if (dateSpans.Count == 0) return false;

            var (start1, len1) = dateSpans[0];
            var dateStr1 = string.Join(" ", tokens.Skip(start1).Take(len1));
            tran = TryParseDateFlexible(dateStr1, p, out var d1) ? d1 : (DateTime?)null;

            if (dateSpans.Count > 1)
            {
                var (start2, len2) = dateSpans[1];
                var dateStr2 = string.Join(" ", tokens.Skip(start2).Take(len2));
                value = TryParseDateFlexible(dateStr2, p, out var d2) ? d2 : (DateTime?)null;
                firstNonDateIdx = Math.Max(start1 + len1, start2 + len2);
            }
            else
            {
                value = tran;
                firstNonDateIdx = start1 + len1;
            }

            return tran.HasValue || value.HasValue;
        }

        // Money recognition (supports parentheses and CR/DR suffixes)
        private static readonly Regex CrDrSuffixRx = new(@"\s*(CR|DR)$", RegexOptions.IgnoreCase | RegexOptions.Compiled);
        private static readonly Regex CrDrTokenRx = new(@"^(CR|DR)$", RegexOptions.IgnoreCase | RegexOptions.Compiled);
        private static bool IsCrDr(string s) => CrDrTokenRx.IsMatch(s);

        private static readonly Regex MoneyZeroRx = new(@"^\(?0+(?:\.0{1,2})?\)?$", RegexOptions.Compiled);
        private static readonly Regex PlainIntRx = new(@"^\-?\(?\d{1,12}\)?$", RegexOptions.Compiled);
        /// <summary>Permissive fallback: digits with optional commas/dots and optional parentheses (avoids long refs).</summary>
        private static readonly Regex LooseMoneyRx = new(@"^\-?\(?\d{1,3}(?:,\d{3})*(?:\.\d{1,2})?\)?$|^\-?\(?\d+(?:\.\d{1,2})?\)?$", RegexOptions.Compiled);

        private static bool LooksLikeMoney(string s, Profile p)
        {
            s = (s ?? "").Trim();
            s = p.UgxPreRx.Replace(s, "");
            s = p.UgxSufRx.Replace(s, "");
            if (p.DashRx.IsMatch(s)) return false;

            // Allow trailing CR/DR by stripping for the core check
            var core = CrDrSuffixRx.Replace(s, "");
            return p.MoneyCoreRx.IsMatch(core) || LooseMoneyRx.IsMatch(core);
        }

        private static decimal? ParseMoney(string s, Profile p)
        {
            s = (s ?? "").Trim();
            s = p.UgxPreRx.Replace(s, "");
            s = p.UgxSufRx.Replace(s, "");
            if (p.DashRx.IsMatch(s)) return null;

            // Detect trailing CR/DR sign before parentheses handling
            string? crdr = null;
            var m = CrDrSuffixRx.Match(s);
            if (m.Success) crdr = m.Groups[1].Value.ToUpperInvariant();

            var core = CrDrSuffixRx.Replace(s, "");
            bool negByParens = core.StartsWith("(") && core.EndsWith(")");
            core = core.Trim('(', ')').Replace(",", "");

            if (!decimal.TryParse(core, NumberStyles.AllowLeadingSign | NumberStyles.AllowDecimalPoint,
                                  CultureInfo.InvariantCulture, out var v))
                return null;

            // Apply CR/DR semantics (DR negative, CR positive)
            if (crdr == "DR") v = -Math.Abs(v);
            else if (crdr == "CR") v = Math.Abs(v);

            if (negByParens) v = -Math.Abs(v);
            return v;
        }

        private static bool TryParsePlainMoney(string s, out decimal v)
        {
            bool negByParens = s.StartsWith("(") && s.EndsWith(")");
            var core = s.Trim('(', ')');
            if (!decimal.TryParse(core, NumberStyles.AllowLeadingSign | NumberStyles.AllowDecimalPoint,
                                  CultureInfo.InvariantCulture, out v))
                return false;
            if (negByParens) v = -Math.Abs(v);
            return true;
        }

        private static bool TryFindRightmostBalance(List<string> tokens, Profile p, out int index, out decimal value)
        {
            // Pass 1: Money token (with optional inline CR/DR suffix)
            for (int i = tokens.Count - 1; i >= 0; i--)
            {
                var tok = tokens[i];
                if (LooksLikeMoney(tok, p))
                {
                    var v = ParseMoney(tok, p);
                    if (v.HasValue) { index = i; value = v.Value; return true; }
                }

                // Pass 1b: [amount] [CR|DR] split across tokens
                if (i - 1 >= 0 && IsCrDr(tok) && LooksLikeMoney(tokens[i - 1], p))
                {
                    var combined = tokens[i - 1] + tokens[i]; // "11,387,122" + "DR" => "11,387,122DR"
                    var v2 = ParseMoney(combined, p);
                    if (v2.HasValue) { index = i; value = v2.Value; return true; }
                }
            }

            // Pass 2: zero fallback
            for (int i = tokens.Count - 1; i >= 0; i--)
            {
                if (MoneyZeroRx.IsMatch(tokens[i]) && TryParsePlainMoney(tokens[i], out var v2))
                {
                    index = i; value = v2; return true;
                }
            }

            // Pass 3: plain integer fallback (avoid long reference numbers)
            for (int i = tokens.Count - 1; i >= 0; i--)
            {
                if (PlainIntRx.IsMatch(tokens[i]) && TryParsePlainMoney(tokens[i], out var v3))
                {
                    index = i; value = v3; return true;
                }
            }

            // Pass 4: permissive number pattern (handles odd formatting / OCR)
            for (int i = tokens.Count - 1; i >= 0; i--)
            {
                var tok = tokens[i];
                if (!LooseMoneyRx.IsMatch(tok)) continue;
                var core = tok.Trim('(', ')').Replace(",", "");
                if (!decimal.TryParse(core, NumberStyles.AllowLeadingSign | NumberStyles.AllowDecimalPoint,
                        CultureInfo.InvariantCulture, out var v4)) continue;
                if (tok.StartsWith("(") && tok.EndsWith(")")) v4 = -Math.Abs(v4);
                index = i; value = v4; return true;
            }

            index = -1; value = default;
            return false;
        }

        // ----------------- Ignore markers -----------------

        private static readonly string[] IgnoreDescMarkers =
        {
            "OPENING BALANCE",
            "CLOSING BALANCE",
            "B/F",
            "BROUGHT FORWARD"
        };

        private static bool ContainsIgnoreMarker(string? desc)
        {
            if (string.IsNullOrWhiteSpace(desc)) return false;
            var up = desc.ToUpperInvariant();
            return IgnoreDescMarkers.Any(m => up.Contains(m));
        }

        // ----------------- Profile / Detection -----------------

        private static Profile? DetectProfile(string text)
        {
            if (text.IndexOf("STANBIC", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                // Stanbic with Balance column → compute D/C from balance deltas (intended logic)
                if (text.IndexOf("Opening balance", StringComparison.OrdinalIgnoreCase) >= 0 ||
                    text.IndexOf("Closing balance", StringComparison.OrdinalIgnoreCase) >= 0)
                    return Profiles.StanbicUgWithBalance();
                return Profiles.StanbicUg();
            }
            if (text.IndexOf("CENTENARY", StringComparison.OrdinalIgnoreCase) >= 0)
                return Profiles.Centenary();
            if (text.IndexOf("EQUITY", StringComparison.OrdinalIgnoreCase) >= 0)
                return Profiles.Equity();
            return null;
        }

        public sealed class Profile
        {
            public string BankName { get; init; } = "Generic (Auto)";
            public string[] DateFormats { get; init; } = Array.Empty<string>();
            public MoneySettings Money { get; init; } = new();

            public string[] CutMarkers { get; init; } = Array.Empty<string>();
            public Regex? PageCounterTailRx { get; init; }
            public Regex? GluedHeadersTailRx { get; init; }

            /// <summary>When true, statement has one amount per row (no balance column). D/C set from description keywords.</summary>
            public bool SingleAmountPerRow { get; init; }
            public string[] DebitKeywords { get; init; } = Array.Empty<string>();
            public string[] CreditKeywords { get; init; } = Array.Empty<string>();

            // Compiled helpers
            public Regex DateAnyRx { get; init; } = null!;
            public Regex RowSplitAnyDateRx { get; init; } = null!;
            public Regex MoneyCoreRx { get; init; } = null!;
            public Regex DashRx { get; init; } = new(@"^[-–—]$", RegexOptions.Compiled);
            public Regex UgxPreRx { get; init; } = new(@"^\s*(UGX|Ugx|ugx)\s*", RegexOptions.Compiled);
            public Regex UgxSufRx { get; init; } = new(@"\s*(UGX|Ugx|ugx)\s*$", RegexOptions.Compiled);
        }

        public sealed class MoneySettings
        {
            public bool GroupedWithComma_AllowDecimalsOptional { get; init; } = true;  // 1,234 or 1,234.50
            public bool NoComma_AllowDecimalsOptional { get; init; } = true;          // 1234 or 1234.50
            public bool AllowParenthesesForNegatives { get; init; } = true;           // (1,234.50)
        }

        public static class Profiles
        {
            // Date patterns: d[-/.]m[-/.]{2-4-digit-year} | yyyy[-/.]m[-/.]d | space-separated
            private const string DatePatClassic = @"\d{1,2}(?:[-/–—.])(?:\d{1,2}|[A-Za-z]{3,9})(?:[-/–—.])\d{2,4}";
            private const string DatePatIso = @"\d{4}(?:[-/–—.])\d{1,2}(?:[-/–—.])\d{1,2}";
            private const string DatePatDots = @"\d{1,2}\.\d{1,2}\.\d{2,4}";
            // Space-separated (e.g. "22 02 2025", "22 Feb 2025", "2025 02 22") so blob-start matches
            private const string DatePatSpace = @"\d{1,2}\s+\d{1,2}\s+\d{2,4}";
            private const string DatePatSpaceMonth = @"\d{1,2}\s+[A-Za-z]{3,9}\s+\d{2,4}";
            private const string DatePatIsoSpace = @"\d{4}\s+\d{1,2}\s+\d{1,2}";
            private const string DatePatAny = $"(?:{DatePatClassic}|{DatePatIso}|{DatePatDots}|{DatePatSpace}|{DatePatSpaceMonth}|{DatePatIsoSpace})";

            private static Regex BuildMoneyRegex(MoneySettings h)
            {
                var parts = new List<string>();
                if (h.GroupedWithComma_AllowDecimalsOptional)
                    parts.Add(@"\-?\d{1,3}(?:,\d{3})+(?:\.\d{1,2})?");
                if (h.NoComma_AllowDecimalsOptional)
                    parts.Add(@"\-?\d+(?:\.\d{1,2})?");

                // Accept optional parentheses and optional trailing CR/DR
                var core = string.Join("|", parts);
                var withCrDr = $@"(?:{core})(?:\s*(?:CR|DR))?";
                if (h.AllowParenthesesForNegatives)
                    withCrDr = $@"^\(?{withCrDr}\)?$";
                else
                    withCrDr = $@"^{withCrDr}$";

                return new Regex(withCrDr, RegexOptions.Compiled | RegexOptions.IgnoreCase);
            }

            private static Profile BuildBase(
                string bankName,
                string[] dateFormats,
                MoneySettings money,
                string[] cutMarkers,
                Regex? pageTail,
                Regex? gluedTail,
                bool singleAmountPerRow = false,
                string[]? debitKeywords = null,
                string[]? creditKeywords = null)
            {
                var dateAnyRx = new Regex(DatePatAny, RegexOptions.Compiled | RegexOptions.IgnoreCase);
                var rowSplitAnyDateRx = new Regex($@"(?=(?:^|(?<=\s)){DatePatAny}\b)",
                                                  RegexOptions.Compiled | RegexOptions.IgnoreCase);
                var moneyRx = BuildMoneyRegex(money);

                return new Profile
                {
                    BankName = bankName,
                    DateFormats = dateFormats,
                    Money = money,

                    CutMarkers = cutMarkers,
                    PageCounterTailRx = pageTail,
                    GluedHeadersTailRx = gluedTail,

                    SingleAmountPerRow = singleAmountPerRow,
                    DebitKeywords = debitKeywords ?? Array.Empty<string>(),
                    CreditKeywords = creditKeywords ?? Array.Empty<string>(),

                    DateAnyRx = dateAnyRx,
                    RowSplitAnyDateRx = rowSplitAnyDateRx,
                    MoneyCoreRx = moneyRx
                };
            }

            public static Profile Default()
            {
                return BuildBase(
                    bankName: "Generic (Auto)",
                    dateFormats: new[]
                    {
                        "dd/MM/yyyy","d/M/yyyy","dd-MM-yyyy","d-M-yyyy","dd.M.yyyy","d.M.yyyy",
                        "dd-MMM-yyyy","d-MMM-yyyy","dd MMM yyyy","d MMM yyyy",
                        "yyyy-MM-dd","yyyy/MM/dd","yyyy.MM.dd","MM/dd/yyyy","M/d/yyyy"
                    },
                    money: new MoneySettings
                    {
                        GroupedWithComma_AllowDecimalsOptional = true,
                        NoComma_AllowDecimalsOptional = true,
                        AllowParenthesesForNegatives = true
                    },
                    cutMarkers: new[]
                    {
                        "Disclaimer", "Computer generated copy", "Account owner", "Name of account",
                        "Company Registration No.", "VAT Reg", "TEL:", "Plot", "BANK STATEMENT", "Statement number",
                        "Statement date", "Date Range", "End of report", "Summary of transactions",
                        "Transaction date Value date Transaction description Debits Credits Balance", "Printed"
                    },
                    pageTail: new Regex(@"(?:\bPage\s+\d+\s+of\s+\d+\b.*|[_\s]*\b\d{1,3}\s*/\s*\d{1,3}\b.*)$",
                                        RegexOptions.Compiled | RegexOptions.IgnoreCase),
                    gluedTail: new Regex(@"(?:\|\s*)?(?:Debit:.*|Credit:.*|Balance:.*)$",
                                         RegexOptions.Compiled | RegexOptions.IgnoreCase)
                );
            }

            /// <summary>Stanbic with Balance column: D/C computed from balance deltas (intended logic).</summary>
            public static Profile StanbicUgWithBalance()
            {
                var baseP = Default();
                return BuildBase(
                    bankName: "Stanbic (UG) - with Balance column",
                    dateFormats: baseP.DateFormats,
                    money: baseP.Money,
                    cutMarkers: new[]
                    {
                        "Stanbic Bank Uganda Limited", "Account type", "Account currency",
                        "BANK STATEMENT", "TAX INVOICE", "Summary of transactions",
                        "Transaction date Value date Transaction description Debits Credits Balance",
                        "Transaction Date Value Date Transaction description Debits Credits Balance",
                        "Computer generated copy", "End of report", "Disclaimer"
                    },
                    pageTail: baseP.PageCounterTailRx,
                    gluedTail: baseP.GluedHeadersTailRx,
                    singleAmountPerRow: false
                );
            }

            /// <summary>Stanbic EDL-style: single amount per row, no balance column; D/C from description keywords.</summary>
            public static Profile StanbicUg()
            {
                var baseP = Default();
                return BuildBase(
                    bankName: "Stanbic (UG) - EDL / single-amount",
                    dateFormats: baseP.DateFormats,
                    money: baseP.Money,
                    cutMarkers: new[]
                    {
                        "Stanbic Bank Uganda Limited", "Account type", "Account currency",
                        "BANK STATEMENT", "TAX INVOICE", "Summary of transactions",
                        "Transaction Date Value Date Description Debit Credit Balance"
                    },
                    pageTail: baseP.PageCounterTailRx,
                    gluedTail: baseP.GluedHeadersTailRx,
                    singleAmountPerRow: true,
                    debitKeywords: new[]
                    {
                        " TO UBL ", " TO UBL", "BEER TO UBL", "SPIRITS TO UBL", "SPIRIT TO UBL",
                        "PAYMENT", "PAYTS", "PAYMENT TO", "INTERNET PAYMENT", "FUEL PAYMENT",
                        "FEE", "DUTY", "EXCISE", "PURCHASE", "BOL ", " KUZA BOL ", " BOL "
                    },
                    creditKeywords: new[]
                    {
                        "BEER SALES", "SALES ", "COLLECTION", "ALCOHOL SALES", "BEVERAGES",
                        "EVEREST SHARON", "SHARON ", "GERALD ", "BRIDGET ", "JULIE ", "NIRAV ",
                        "PATEL COLLECTION", "SOKONI AFRICA"
                    }
                );
            }

            public static Profile Centenary()
            {
                var baseP = Default();
                return BuildBase(
                    bankName: "Centenary Bank (UG)",
                    dateFormats: baseP.DateFormats,
                    money: baseP.Money,
                    cutMarkers: new[]
                    {
                        "Centenary", "Centenary Bank", "DEMAND DEPOSIT STATEMENT", "Branch", "e-mail", "PAGE:",
                        "SUMMARY OF TRANSACTIONS", "BOOK BALANCE:", "AVAILABLE BALANCE:", "UNCLEAR BALANCE:"
                    },
                    pageTail: baseP.PageCounterTailRx,
                    gluedTail: baseP.GluedHeadersTailRx
                );
            }

            public static Profile Equity()
            {
                var baseP = Default();
                return BuildBase(
                    bankName: "Equity Bank (UG)",
                    dateFormats: baseP.DateFormats,
                    money: baseP.Money,
                    cutMarkers: new[]
                    {
                        "EQUITY BANK", "Account Statement", "Statement Period", "Opening Balance", "Closing Balance",
                        "Total Debit", "Total Credit", "Summary", "Disclaimer", "Grand Total"
                    },
                    pageTail: baseP.PageCounterTailRx,
                    gluedTail: baseP.GluedHeadersTailRx
                );
            }
        }
    }

}
